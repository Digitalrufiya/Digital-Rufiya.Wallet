<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>DRF Marketplace (Payment Verified Upload)</title>
<style>
  body { font-family: Arial, sans-serif; margin:0; padding:18px; background:#f3f4f6; color:#111; }
  #upload-section { background:#fff; padding:16px; border-radius:10px; box-shadow:0 6px 18px rgba(0,0,0,0.06); max-width:900px; margin:auto; }
  input, textarea, button { box-sizing:border-box; width:100%; margin:8px 0; padding:10px; border-radius:6px; border:1px solid #d1d5db; }
  button{ background:#2563eb; color:#fff; border:none; padding:10px; cursor:pointer; }
  button.secondary{ background:#10b981; }
  button:disabled{ background:#9ca3af; cursor:default; }
  #posts{ max-width:900px; margin:18px auto; }
  .post{ background:#fff; padding:14px; border-radius:8px; margin-bottom:14px; box-shadow:0 4px 12px rgba(0,0,0,0.04); }
  .buttons{ display:flex; gap:8px; margin-top:10px; flex-wrap:wrap; }
  .note{ font-size:13px; color:#374151; margin-top:8px; }
  .small{ font-size:13px; color:#6b7280; }
</style>
</head>
<body>

<section id="upload-section">
  <h2>Upload Listing — Payment Required (1 USDC)</h2>

  <!-- media + details -->
  <input type="file" id="mediaInput" accept="image/*,video/*" />
  <input type="text" id="titleInput" placeholder="Title" />
  <textarea id="descriptionInput" placeholder="Description" rows="3"></textarea>
  <input type="number" id="priceInput" placeholder="Price (USD)" />
  <input type="text" id="locationInput" placeholder="Location" />
  <input type="text" id="whatsappInput" placeholder="WhatsApp Number" />

  <!-- Payment -->
  <div style="display:flex;gap:8px;">
    <button id="payBtn">Open Trust Wallet (Pay 1 USDC)</button>
    <button id="openWalletBtn" style="background:#111827">Open Wallet (MetaMask)</button>
  </div>
  <div class="note">After you complete payment in your wallet, paste the <strong>transaction hash</strong> here and click <em>Verify Payment</em>.</div>

  <input type="text" id="txHashInput" placeholder="Paste transaction hash (0x...)" />
  <div style="display:flex;gap:8px;">
    <button id="verifyBtn" class="secondary">Verify Payment</button>
    <button id="enableUploadBtn" disabled>Enable Upload (locked)</button>
  </div>

  <div id="uploadStatus" class="small" style="margin-top:10px"></div>

  <div style="margin-top:12px">
    <button id="uploadBtn" disabled>Upload Listing</button>
  </div>

  <p class="small">Important: this page verifies on-chain transfer to the project wallet. Do not enable upload unless verification is successful.</p>
</section>

<section id="posts"></section>

<script type="module">
/* =============================================================
  CONFIG - update these values for your deployment
  - OWNER_ADDRESS: wallet that should receive 1 USDC
  - USDC_CONTRACT: BEP20 token contract address for USDC on BSC
  - BSCSCAN_API_KEY: get from https://bscscan.com/apis (free tier)
  - pinataJWT: (TEMPORARY) for Pinata uploads — move to backend ASAP
  - FIREBASE CONFIG: kept same as your file (firestore usage)
=============================================================*/

// === MUST set these values ===
const OWNER_ADDRESS = "0x88253D87990EdD1E647c3B6eD21F57fb061a3040".toLowerCase(); // your receive wallet
const USDC_CONTRACT = "0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d".toLowerCase(); // BSC USDC (example)
const REQUIRED_AMOUNT = BigInt(1) * BigInt(10 ** 18); // 1 USDC with 18 decimals (adjust if token has different decimals)
const BSCSCAN_API_KEY = "YOUR_BSCSCAN_API_KEY_HERE"; // <<--- put your BscScan API key here
// Temporary Pinata JWT (your original file used this). Move to Cloud Function / backend for security:
const pinataJWT = "REPLACE_WITH_PINATA_JWT_OR_USE_BACKEND";

/* ========== end config ========== */

/* Helper: hex to bigint */
function hexToBigInt(hex) {
  if (typeof hex !== "string") return BigInt(0);
  if (hex.startsWith("0x")) hex = hex.slice(2);
  if (hex === "") return BigInt(0);
  return BigInt("0x" + hex);
}

/* UI elements */
const payBtn = document.getElementById("payBtn");
const openWalletBtn = document.getElementById("openWalletBtn");
const txHashInput = document.getElementById("txHashInput");
const verifyBtn = document.getElementById("verifyBtn");
const enableUploadBtn = document.getElementById("enableUploadBtn");
const uploadBtn = document.getElementById("uploadBtn");
const uploadStatus = document.getElementById("uploadStatus");

/* open Trust Wallet link (pre-filled) */
const trustLink = `https://link.trustwallet.com/send?coin=20000714&address=${OWNER_ADDRESS}&amount=1.0&token_id=${USDC_CONTRACT}`;
payBtn.onclick = () => {
  window.open(trustLink, "_blank");
  alert("Trust Wallet opened. Complete payment and paste tx hash, then click Verify Payment.");
};

/* optional: open MetaMask if user prefers (for web3 payments) */
openWalletBtn.onclick = async () => {
  if (window.ethereum) {
    try {
      await window.ethereum.request({ method: "eth_requestAccounts" });
      alert("Wallet connected (MetaMask). You may also pay using your wallet.");
    } catch (e) { console.error(e); alert("Wallet connect failed"); }
  } else alert("MetaMask not found in browser");
};

/* Verify transaction on BSC (via BscScan proxy eth_getTransactionByHash + eth_getTransactionReceipt)
   Approach:
   - Retrieve transaction by hash
   - Ensure tx.to equals USDC_CONTRACT (token contract)
   - Decode input payload for transfer: 0xa9059cbb(address,uint256)
   - Extract recipient and amount; ensure recipient == OWNER_ADDRESS and amount >= REQUIRED_AMOUNT
   - Also verify receipt status = 1 (success)
*/
verifyBtn.onclick = async () => {
  const txHash = (txHashInput.value || "").trim();
  if (!txHash || !txHash.startsWith("0x")) { alert("Paste a valid tx hash (0x...)"); return; }
  uploadStatus.textContent = "Verifying transaction on BSC... (please wait)";
  try {
    // 1) get transaction details (proxy API)
    const txUrl = `https://api.bscscan.com/api?module=proxy&action=eth_getTransactionByHash&txhash=${txHash}&apikey=${BSCSCAN_API_KEY}`;
    const txRes = await fetch(txUrl);
    const txJson = await txRes.json();
    if (!txJson || !txJson.result) throw new Error("Transaction not found");

    // 2) get receipt to check status
    const rcptUrl = `https://api.bscscan.com/api?module=proxy&action=eth_getTransactionReceipt&txhash=${txHash}&apikey=${BSCSCAN_API_KEY}`;
    const rcptRes = await fetch(rcptUrl);
    const rcptJson = await rcptRes.json();
    if (!rcptJson || !rcptJson.result) throw new Error("Receipt not found");

    const tx = txJson.result;
    const receipt = rcptJson.result;

    // ensure tx was successful
    if (receipt.status !== "0x1") throw new Error("Transaction failed on-chain");

    // check 'to' field equals token contract (lowercase compare)
    const txTo = (tx.to || "").toLowerCase();
    if (txTo !== USDC_CONTRACT) {
      // If user used transferFrom via another contract or paid in native BNB, we reject here.
      throw new Error("Transaction not to the expected token contract. Please pay 1 USDC to the project wallet.");
    }

    // decode input: method is first 4 bytes (8 hex chars) after 0x
    const input = tx.input || "";
    const methodId = input.slice(0, 10); // "0x" + 8chars
    if (methodId !== "0xa9059cbb") {
      throw new Error("Transaction input not token transfer (expected transfer signature).");
    }

    // input structure: 0xa9059cbb + 32bytes(recipient) + 32bytes(amount)
    // recipient at bytes 4..36 => hex positions 10..74
    const recipientHex = "0x" + input.slice(10 + 24, 10 + 64); // skip leading zeros of padded address
    const recipient = recipientHex.toLowerCase();
    // amount at last 32 bytes:
    const amountHex = "0x" + input.slice(input.length - 64);
    const amount = hexToBigInt(amountHex);

    // verify recipient equals OWNER
    if (recipient !== OWNER_ADDRESS) throw new Error("Token recipient does not match project wallet");

    // verify amount >= required
    if (amount < REQUIRED_AMOUNT) throw new Error("Sent amount is less than required 1 USDC");

    // passed checks
    uploadStatus.textContent = `✅ Payment verified on-chain. Sender: ${tx.from}. Amount: ${amount.toString()}`;
    enableUploadBtn.disabled = false;
    uploadBtn.disabled = false;
    uploadBtn.dataset.verifiedTx = txHash; // store txHash for uploading record
  } catch (err) {
    console.error(err);
    uploadStatus.textContent = "❌ Verification error: " + (err.message || err);
    alert("Verification failed: " + (err.message || err));
  }
};

/* --------- Pinata + Firestore (kept similar to your original) ---------
   NOTE: Keeping Pinata JWT in client is not secure. Move to a backend soon.
   This sample uses your original firebase imports style (you can adapt).
-------------------------------------------------------------------------*/

/* Use your Firebase config (same as your working file). If you already
   have firebase scripts imported elsewhere, adapt accordingly.
   For brevity here we use dynamic imports like your original file. */
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-app.js";
import { getFirestore, collection, addDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-firestore.js";
import { getAuth, onAuthStateChanged, signInAnonymously } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-auth.js";

const firebaseConfig = {
  apiKey: "AIzaSyDBxNIIuYonkgF9m8QYdUFDOXIXAM6FYqA",
  authDomain: "drfmarket-place.firebaseapp.com",
  projectId: "drfmarket-place",
  storageBucket: "drfmarket-place.firebasestorage.app",
  messagingSenderId: "752616443115",
  appId: "1:752616443115:web:73b71924daf66ae9c882ae",
  measurementId: "G-MV9JQZHLLY"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
const auth = getAuth(app);

let currentUser = null;
onAuthStateChanged(auth, user => {
  if (user) currentUser = user;
  else signInAnonymously(auth).catch(console.error);
});

/* Upload file to Pinata (client) - temporary; move to backend later */
async function uploadToPinata(file) {
  if (!pinataJWT || pinataJWT === "REPLACE_WITH_PINATA_JWT_OR_USE_BACKEND") {
    throw new Error("Pinata JWT not configured. Move upload to a backend Cloud Function.");
  }
  const url = "https://api.pinata.cloud/pinning/pinFileToIPFS";
  const data = new FormData();
  data.append("file", file);
  const res = await fetch(url, { method: "POST", headers: { Authorization: `Bearer ${pinataJWT}` }, body: data });
  if (!res.ok) {
    const txt = await res.text();
    throw new Error("Pinata upload failed: " + txt);
  }
  const json = await res.json();
  return json.IpfsHash;
}

uploadBtn.onclick = async () => {
  const fileInput = document.getElementById("mediaInput");
  const title = document.getElementById("titleInput").value.trim();
  const description = document.getElementById("descriptionInput").value.trim();
  const price = parseFloat(document.getElementById("priceInput").value);
  const location = document.getElementById("locationInput").value.trim();
  const whatsapp = document.getElementById("whatsappInput").value.trim();
  const verifiedTx = uploadBtn.dataset.verifiedTx || enableUploadBtn.dataset.verifiedTx || "";

  if (!fileInput.files[0] || !title || !description || isNaN(price) || !location || !whatsapp) {
    alert("All fields required");
    return;
  }
  if (!verifiedTx) {
    alert("Listing must be backed by a verified payment transaction");
    return;
  }

  uploadBtn.disabled = true;
  uploadStatus.textContent = "Uploading media to IPFS (Pinata)...";

  try {
    const ipfsHash = await uploadToPinata(fileInput.files[0]);
    const mediaType = fileInput.files[0].type.startsWith("video") ? "video" : "image";

    // store in Firestore (include verified txHash)
    await addDoc(collection(db, "posts"), {
      title, description, price, location, whatsapp,
      ipfsHash, mediaType, createdAt: serverTimestamp(),
      verifiedTx
    });

    uploadStatus.textContent = "Upload successful! Listing published.";
    fileInput.value = "";
    // Optionally refresh feed (not implemented here)
  } catch (err) {
    console.error(err);
    uploadStatus.textContent = "Upload error: " + (err.message || err);
    alert("Upload failed: " + (err.message || err));
  } finally {
    uploadBtn.disabled = false;
  }
};

/* OPTIONAL: if you want the Enable Upload button to use the same txHash
   (this was used to store txHash when verify succeeded) */
enableUploadBtn.onclick = () => {
  const tx = txHashInput.value.trim();
  if (!tx) return alert("Paste tx hash first");
  enableUploadBtn.disabled = true;
  enableUploadBtn.dataset.verifiedTx = tx;
  uploadBtn.dataset.verifiedTx = tx;
  uploadStatus.textContent = "Upload enabled (tx recorded). You may now Upload Listing.";
};

</script>
</body>
</html>
