<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>DRFChain Feed</title>
<script src="https://cdn.ethers.io/lib/ethers-5.6.umd.min.js" type="application/javascript"></script>
<style>
  body { font-family: Arial, sans-serif; margin: 20px; max-width: 900px; }
  #connectBtn { margin-bottom: 20px; padding: 10px 20px; font-size: 18px; }
  .post { border: 1px solid #ccc; padding: 15px; margin-bottom: 20px; border-radius: 8px; }
  .post img, .post video { max-width: 100%; max-height: 300px; margin: 10px 0; border-radius: 8px; }
  .likes, .comments-count { font-weight: bold; margin-right: 15px; }
  button { margin-right: 10px; padding: 8px 12px; cursor: pointer; }
  #newPostForm { margin-bottom: 30px; }
  textarea { width: 100%; height: 80px; }
  input[type=text] { width: 100%; padding: 8px; margin-top: 5px; }
  .comments { margin-top: 15px; border-top: 1px solid #ddd; padding-top: 10px; }
  .comment { border-bottom: 1px solid #eee; padding: 5px 0; }
  .flagged { background-color: #ffd6d6; }
</style>
</head>
<body>

<h1>DRFChain Social Feed</h1>
<button id="connectBtn">Connect Wallet</button>
<div id="account"></div>

<div id="newPostForm" style="display:none;">
  <h3>Create New Post</h3>
  <label>IPFS Hash:</label>
  <input type="text" id="ipfsHashInput" placeholder="Enter IPFS hash (CID)" required />
  <label>Media Type:</label>
  <select id="mediaTypeSelect">
    <option value="image">Image</option>
    <option value="video">Video</option>
  </select>
  <button id="postBtn">Post</button>
  <div id="postStatus"></div>
</div>

<hr />

<div id="posts"></div>

<script>
  const contractAddress = "0xYourContractAddressHere"; // Replace with your contract address
  const contractABI = [
    // Relevant parts of ABI
    "function totalPosts() view returns (uint256)",
    "function getPost(uint256) view returns (address,string,string,uint256,bool,uint256)",
    "function post(string ipfsHash, string mediaType)",
    "function likePost(uint256)",
    "function commentOnPost(uint256, string memory)",
    "function getComments(uint256) view returns (tuple(address,string,uint256)[])",
    "function owner() view returns (address)"
  ];

  let provider, signer, contract, userAddress;

  const connectBtn = document.getElementById('connectBtn');
  const accountDiv = document.getElementById('account');
  const postsDiv = document.getElementById('posts');
  const newPostForm = document.getElementById('newPostForm');
  const ipfsHashInput = document.getElementById('ipfsHashInput');
  const mediaTypeSelect = document.getElementById('mediaTypeSelect');
  const postBtn = document.getElementById('postBtn');
  const postStatus = document.getElementById('postStatus');

  connectBtn.onclick = async () => {
    if (!window.ethereum) {
      alert("Please install MetaMask or compatible wallet");
      return;
    }
    try {
      provider = new ethers.providers.Web3Provider(window.ethereum);
      await provider.send("eth_requestAccounts", []);
      signer = provider.getSigner();
      userAddress = await signer.getAddress();
      contract = new ethers.Contract(contractAddress, contractABI, signer);

      accountDiv.textContent = `Connected: ${userAddress}`;
      connectBtn.style.display = 'none';
      newPostForm.style.display = 'block';

      loadPosts();
    } catch (err) {
      alert("Connection error: " + err.message);
    }
  };

  postBtn.onclick = async () => {
    const ipfsHash = ipfsHashInput.value.trim();
    const mediaType = mediaTypeSelect.value;

    if (!ipfsHash) {
      alert("Please enter IPFS hash");
      return;
    }

    try {
      postStatus.textContent = "Posting...";
      const tx = await contract.post(ipfsHash, mediaType);
      await tx.wait();
      postStatus.textContent = "Post created successfully!";
      ipfsHashInput.value = "";
      loadPosts();
    } catch (err) {
      postStatus.textContent = "Post failed: " + (err.data?.message || err.message);
    }
  };

  async function loadPosts() {
    postsDiv.innerHTML = "Loading posts...";
    try {
      const total = await contract.totalPosts();
      postsDiv.innerHTML = "";
      for (let i = total - 1; i >= 0; i--) {
        const post = await contract.getPost(i);
        const [poster, ipfsHash, mediaType, timestamp, flagged, likes] = post;
        const postDiv = document.createElement('div');
        postDiv.className = 'post';
        if(flagged) postDiv.classList.add('flagged');

        const mediaUrl = `https://gateway.pinata.cloud/ipfs/${ipfsHash}`;

        postDiv.innerHTML = `
          <div><strong>Poster:</strong> ${poster}</div>
          <div><strong>Time:</strong> ${new Date(timestamp * 1000).toLocaleString()}</div>
          <div>
            ${mediaType === 'video' ? 
              `<video src="${mediaUrl}" controls></video>` : 
              `<img src="${mediaUrl}" alt="Post Media" />`}
          </div>
          <div><strong>Likes:</strong> ${likes.toString()}</div>
          <button onclick="likePost(${i})">Like</button>
          <button onclick="toggleCommentForm(${i})">Comment</button>
          <div id="commentForm-${i}" style="display:none; margin-top:10px;">
            <textarea id="commentInput-${i}" placeholder="Write a comment"></textarea><br/>
            <button onclick="submitComment(${i})">Submit Comment</button>
            <div id="commentStatus-${i}"></div>
            <div id="commentsList-${i}"></div>
          </div>
          <div id="commentsContainer-${i}" style="margin-top:10px;"></div>
        `;

        postsDiv.appendChild(postDiv);
      }
    } catch (err) {
      postsDiv.innerHTML = "Error loading posts: " + err.message;
    }
  }

  async function likePost(postId) {
    try {
      const tx = await contract.likePost(postId);
      await tx.wait();
      alert("Liked post!");
      loadPosts();
    } catch (err) {
      alert("Like failed: " + (err.data?.message || err.message));
    }
  }

  function toggleCommentForm(postId) {
    const form = document.getElementById(`commentForm-${postId}`);
    if (form.style.display === 'block') {
      form.style.display = 'none';
    } else {
      form.style.display = 'block';
      loadComments(postId);
    }
  }

  async function submitComment(postId) {
    const input = document.getElementById(`commentInput-${postId}`);
    const status = document.getElementById(`commentStatus-${postId}`);
    const commentText = input.value.trim();

    if (!commentText) {
      alert("Comment cannot be empty");
      return;
    }

    try {
      status.textContent = "Submitting comment...";
      const tx = await contract.commentOnPost(postId, commentText);
      await tx.wait();
      status.textContent = "Comment submitted!";
      input.value = "";
      loadComments(postId);
      loadPosts();
    } catch (err) {
      status.textContent = "Comment failed: " + (err.data?.message || err.message);
    }
  }

  async function loadComments(postId) {
    const commentsList = document.getElementById(`commentsList-${postId}`);
    try {
      const comments = await contract.getComments(postId);
      commentsList.innerHTML = "<strong>Comments:</strong><br/>";
      if (comments.length === 0) {
        commentsList.innerHTML += "<em>No comments yet</em>";
        return;
      }
      comments.forEach(c => {
        const [commenter, message, time] = c;
        const d = new Date(time * 1000).toLocaleString();
        commentsList.innerHTML += `<div><strong>${commenter}</strong> (${d}):<br/>${message}</div><hr/>`;
      });
    } catch (err) {
      commentsList.innerHTML = "Failed to load comments";
    }
  }
</script>

</body>
</html>
