<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>FENTOM — Debug 3D Preview</title>
  <style>
    html,body{height:100%;margin:0;background:#071021;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;color:#e6eef6}
    #app{display:flex;height:100vh;gap:12px;padding:12px;box-sizing:border-box}
    #viewport{flex:1;border-radius:8px;overflow:hidden;background:linear-gradient(180deg,#06101a,#0b1926);box-shadow:0 10px 40px rgba(0,0,0,0.7)}
    #panel{width:360px;min-width:260px;background:linear-gradient(180deg,#071827,#03121a);border-radius:10px;padding:16px;box-shadow:0 8px 30px rgba(0,0,0,0.6)}
    h2{margin:0 0 8px 0;font-weight:600}
    .row{display:flex;gap:8px;align-items:center;margin-bottom:10px}
    label{width:110px;color:#98a8bf;font-size:13px}
    input[type=range]{flex:1}
    .btn{display:inline-block;padding:8px 10px;border-radius:8px;background:#0b2330;color:#00d1b2;border:1px solid rgba(0,209,178,0.06);cursor:pointer}
    .info{margin-top:12px;color:#9fb0c6;font-size:13px}
    .stat{display:flex;gap:8px;align-items:center;margin-top:8px}
    .stat .value{font-size:20px;color:#fff;font-weight:700}
    footer{position:absolute;left:16px;bottom:16px;color:#6b7f92;font-size:12px}
  </style>
</head>
<body>
  <div id="app">
    <div id="viewport"></div>
    <div id="panel">
      <h2>FENTOM — 3D Debug Preview</h2>
      <div class="row"><label>Flywheel RPM</label><input id="rpmSlider" type="range" min="0" max="5000" value="800"></div>
      <div class="row"><label>Coil Power</label><input id="coilSlider" type="range" min="0" max="1" step="0.01" value="0.3"></div>
      <div class="row"><label>Clutch Gap (mm)</label><input id="gapSlider" type="range" min="1" max="8" value="3"></div>
      <div style="display:flex;gap:8px;margin-top:8px"><button id="startBtn" class="btn">Start</button><button id="stopBtn" class="btn">Stop</button></div>

      <div class="info">
        <div>Controls: drag to orbit, scroll to zoom. This debug build adds helpers and stronger lighting so you can confirm the scene.</div>

        <div class="stat">
          <div style="flex:1">
            <div style="color:#98a8bf;font-size:12px">Estimated Torque</div>
            <div class="value" id="torqueVal">-- Nm</div>
          </div>
          <div style="flex:1">
            <div style="color:#98a8bf;font-size:12px">Stored Energy</div>
            <div class="value" id="energyVal">-- J</div>
          </div>
        </div>

      </div>
      <div style="margin-top:12px;color:#8fa3b8;font-size:13px">If you still see only zoom, try opening Console (F12) and tell me any errors you see.</div>
    </div>
  </div>

  <!-- Three.js + OrbitControls from CDN -->
  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.152.2/examples/js/controls/OrbitControls.js"></script>
  <script>
    // DOM
    const container = document.getElementById('viewport');

    // Renderer (robust sizing using resize observer / fallback)
    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(Math.max(1, window.devicePixelRatio || 1));
    renderer.setClearColor(0x071021);
    container.appendChild(renderer.domElement);

    // Scene + camera
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x071021);
    const camera = new THREE.PerspectiveCamera(45, 2, 0.1, 3000);
    camera.position.set(300, 220, 420);

    // Controls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.12;
    controls.rotateSpeed = 0.6;

    // Lighting - stronger so things are visible
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dir = new THREE.DirectionalLight(0xffffff, 1.2);
    dir.position.set(120,200,120);
    scene.add(dir);
    const dir2 = new THREE.DirectionalLight(0xfff2c1, 0.3);
    dir2.position.set(-200,-100,50);
    scene.add(dir2);

    // helpers to ensure visibility
    const axes = new THREE.AxesHelper(180); scene.add(axes);
    const grid = new THREE.GridHelper(500, 20, 0x13303b, 0x082029); grid.position.y = -100; scene.add(grid);

    // Base
    const baseMat = new THREE.MeshStandardMaterial({color:0x0b1520, metalness:0.4, roughness:0.6});
    const baseGeo = new THREE.CylinderGeometry(220,220,8,64);
    const base = new THREE.Mesh(baseGeo, baseMat);
    base.rotation.x = Math.PI/2; base.position.y = -108; scene.add(base);

    // Assembly group
    const assembly = new THREE.Group(); scene.add(assembly);

    // Shaft
    const shaftMat = new THREE.MeshStandardMaterial({color:0xa3a3a3, metalness:1, roughness:0.25});
    const shaftGeo = new THREE.CylinderGeometry(6,6,420,32);
    const shaft = new THREE.Mesh(shaftGeo, shaftMat); shaft.rotation.z = Math.PI/2; assembly.add(shaft);

    // Flywheel (visible)
    const flyMat = new THREE.MeshStandardMaterial({color:0x29323b, metalness:0.9, roughness:0.3});
    const flyGeo = new THREE.CylinderGeometry(90,90,20,64);
    const flywheel = new THREE.Mesh(flyGeo, flyMat); flywheel.rotation.z = Math.PI/2; flywheel.position.set(0,0,0); assembly.add(flywheel);

    // test cube (guaranteed visible)
    const cube = new THREE.Mesh(new THREE.BoxGeometry(40,40,40), new THREE.MeshStandardMaterial({color:0xff6b6b,emissive:0x220000}));
    cube.position.set(180, 0, 0);
    assembly.add(cube);

    // magnet group (visual)
    const magnetGroup = new THREE.Group();
    const magCount = 12;
    for(let i=0;i<magCount;i++){
      const magGeo = new THREE.BoxGeometry(18,6,6);
      const magMat = new THREE.MeshStandardMaterial({color:(i%2?0xff6b6b:0xffd166), metalness:0.6, roughness:0.4});
      const mag = new THREE.Mesh(magGeo, magMat);
      const angle = i*(Math.PI*2/magCount);
      mag.position.set(Math.cos(angle)*110, Math.sin(angle)*110, 0);
      mag.rotation.z = angle; magnetGroup.add(mag);
    }
    assembly.add(magnetGroup);

    // outer tire visual
    const tireMat = new THREE.MeshStandardMaterial({color:0x081826,metalness:0.15,roughness:0.85});
    const tire = new THREE.Mesh(new THREE.TorusGeometry(250,40,64,200), tireMat);
    tire.rotation.z = Math.PI/2; tire.position.set(0,0,-30); assembly.add(tire);

    // UI state & controls binding
    const rpmSlider = document.getElementById('rpmSlider');
    const coilSlider = document.getElementById('coilSlider');
    const gapSlider = document.getElementById('gapSlider');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const torqueVal = document.getElementById('torqueVal');
    const energyVal = document.getElementById('energyVal');

    let state = { running:false, rpm: 800, coilPower:0.3, clutchGap:3, torque:0 };

    rpmSlider.addEventListener('input', e => state.rpm = Number(e.target.value));
    coilSlider.addEventListener('input', e => state.coilPower = Number(e.target.value));
    gapSlider.addEventListener('input', e => state.clutchGap = Number(e.target.value));
    startBtn.addEventListener('click', ()=> state.running = true);
    stopBtn.addEventListener('click', ()=> state.running = false);

    // simple compute
    function computeTorque(){
      const Nm_per_pole = 7;
      const gap = state.clutchGap;
      const gapFactor = Math.max(0, 1 - (gap-1)/6);
      const engagedPoles = Math.round(magCount * 0.6);
      const magTorque = Nm_per_pole * engagedPoles * gapFactor;
      const coilTorque = state.coilPower * 25;
      const total = (magTorque + coilTorque) * 0.9;
      state.torque = total;
      return total;
    }

    const flyMass = 6, flyR = 0.1, I = 0.5*flyMass*flyR*flyR;
    function computeEnergy(rpm){ const omega = rpm * 2*Math.PI/60; return 0.5 * I * omega*omega; }

    // render sizing robustly
    function resizeRenderer(){
      const rect = container.getBoundingClientRect();
      renderer.setSize(Math.max(160, Math.floor(rect.width)), Math.max(160, Math.floor(rect.height)), false);
      camera.aspect = rect.width / rect.height;
      camera.updateProjectionMatrix();
    }
    new ResizeObserver(resizeRenderer).observe(container);
    resizeRenderer();

    // animation loop
    let last = performance.now();
    function animate(now){
      requestAnimationFrame(animate);
      const dt = (now - last)/1000; last = now;
      controls.update();

      if(state.running){
        const torque = computeTorque();
        const friction = 0.02 * state.rpm;
        const rpmChange = (torque*8 - friction) * dt;
        state.rpm = Math.max(0, state.rpm + rpmChange);
      } else {
        state.rpm = Number(rpmSlider.value);
      }

      const flyRot = (state.rpm/60) * 2*Math.PI * (now/1000);
      flywheel.rotation.x = flyRot;
      magnetGroup.rotation.x = flyRot*0.98;
      tire.rotation.x = flyRot * Math.max(0, Math.min(1, computeTorque()/200)) * 0.85;
      cube.rotation.y += 0.6 * dt;

      torqueVal.textContent = computeTorque().toFixed(1) + ' Nm';
      energyVal.textContent = computeEnergy(state.rpm).toFixed(1) + ' J';

      renderer.render(scene, camera);
    }
    animate(performance.now());

    // console tip: if still nothing visible -> open console (F12) and paste errors here
  </script>
</body>
</html>
